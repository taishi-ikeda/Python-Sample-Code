\documentclass[dvipdfmx,pic,eepic,ecltree]{jarticle}

\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage{itembkbx}
\usepackage{boites,boites_exemples}
\usepackage{lipsum}
% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{ascmac}
\usepackage[many]{tcolorbox}
\tcbuselibrary{breakable, skins, theorems}
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
\lstset{%
  language={Python},
  basicstyle={\small},%
  identifierstyle={\small},%
  commentstyle={\small\itshape\color[rgb]{0,0.5,0}},%
  keywordstyle={\small\bfseries\color[rgb]{0,0,1}},%
  ndkeywordstyle={\small},%
  stringstyle={\small\ttfamily\color[rgb]{1,0,1}},
  frame={tb},
  breaklines=true,
  columns=[l]{fullflexible},%
  numbers=left,%
  xrightmargin=0zw,%
  xleftmargin=3zw,%
  numberstyle={\scriptsize},%
  stepnumber=1,
  numbersep=1zw,%
  lineskip=-0.5ex%
}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary {shapes.misc}
\usetikzlibrary{positioning}
\usepackage{algorithmic}
\usepackage{algorithm}
\title{ソートのアルゴリズム}
\author{}
\date{}
\begin{document}
\maketitle
\section{はじめに}
与えられた実数の並びを規則に従って並べ替えることをソートと呼びます。ソートのアルゴリズムはすでにさまざまに研究がされており、
各種プログラミングですでに実装されています。このノートではアルゴリズムの勉強のためにソートの有名どころのアルゴリズムを実装
してみます。

まず、アルゴリズムそのものの説明に入る前にソートとは何かを例で見てみます。
例えば、以下の実数の並びが与えられているとします。
\begin{eqnarray}
4,~8,~1,~-3,~5.1,~-7.2,~10
\end{eqnarray}
これを小さな数字順、すなわち左が小さな数字、右が大きな数字になるように並び替えると以下のようになります。
\begin{eqnarray}
-7.2,~-3,~1,~4,~5.1,~8,~10
\end{eqnarray}
このようにある一定の規則に従って並べ替えることをソートと呼びます。この並べ替えは必ずしも小さな数字順で
ある必要はなく大きな数字から順に小さな数字へと並べていっても構いません。ただし以下ではこのノードではソートというとき
小さな数字の順番に並べることを意味するとします。

上にあげた問題は数字が７つでしたのでソートを行うのに大した手間ではなかったですが、
実際のデータを扱うときにはずっと大きな文字の並びになることもあるでしょう。そのようなときに如何に効率的に
ソートを行うのかは古くからある重要な問題です。このノートではよく知られているアルゴリズムとしてバブルソート、
セレクションソート、インサーションソート、シェルソート、ヒープソート、クイックソート、マージソート
について扱います。それぞれのアルゴリズムについてPythonで実装したものをgithubに挙げています。

\section{アルゴリズムと実装}
それではそれぞれのアルゴリズムの詳細について説明していきます。以下では数字の列の大きさを$n$とします。
\subsection{バブルソート}
与えられた数字の列に対してソートの後の数字の列の並び合う数字を比較すると左の数字より右の数字が大きいはずです。
このことから順番に隣り合う数字を確認していって左の数字が右のより大きければ入れ替えるという操作をすることでソートを
実現できそうなことがわかります。この考え方を使ってバブルソートでは、列の先頭から順番に隣り合う数字を比較していき
左の数字が右の数字より大きな数字のときには、数字を入れ替えるという作業を行います。この操作を最後まで行うと列の
1番右側(n番目)に一番大きな数字が来ることがわかります。このとき一番右の数字以外はまだソートが完了していません。
そこで、次に列の先頭からn-1番目の数字までを同様に隣同士の大小比較をして数字を並べ替えていきます。以下、順番に繰り返していくことで
最終的にソートされた数字の列を得ることができます。

具体的にこのアルゴリズムを見るために以下の数字の列を考えます。
\begin{eqnarray}\label{example init}
5, 4, 8, 1, 3, 2, 7, 6
\end{eqnarray}
まず、先頭の数字から隣り合う数字を比較して順番に最後まで数字を並べ替えていくと以下のようになります。
\begin{eqnarray}
4, 5, 8, 1, 3, 2, 7, 6\\
4, 5, 1, 8, 3, 2, 7, 6\\
4, 5, 1, 3, 8, 2, 7, 6\\
4, 5, 1, 3, 2, 8, 7, 6\\
4, 5, 1, 3, 2, 7, 8, 6\\
4, 5, 1, 3, 2, 7, 6, 8
\end{eqnarray}
この段階で一番右の数字が、最大の数になっていることがわかります。一方で、他の箇所についてはまだ数字が小さな順に並んでいません。
そこで再び先頭から隣り合う数字の大小関係に基づいて数字を並べ替えていきます。
\begin{eqnarray}
4, 5, 1, 3, 2, 7, 6, 8\\
4, 1, 5, 3, 2, 7, 6, 8\\
4, 1, 3, 5, 2, 7, 6, 8\\
4, 1, 3, 2, 5, 7, 6, 8\\
4, 1, 3, 2, 5, 6, 7, 8
\end{eqnarray}
これで最後の数字二つはソートされていることがわかります。この手続きを繰り返すと、
\begin{eqnarray}
4, 1, 3, 2, 5, 6, 7, 8\\
1, 4, 3, 2, 5, 6, 7, 8\\
1, 3, 4, 2, 5, 6, 7, 8\\
1, 3, 2, 4, 5, 6, 7, 8\\
1, 2, 3, 4, 5, 6, 7, 8\\
1, 2, 3, 4, 5, 6, 7, 8
\end{eqnarray}
となり、最終的に全体がソートされた結果が得られます。
このアルゴリズムを疑似コードで書くと以下のようになります。
\begin{figure}[H]
\begin{algorithm}[H]
	\caption{bubble sort}
	\label{bubble sort}
	\begin{algorithmic}[1]  
    	\FOR{$i=0;i<n-1;++i$}
	\FOR{$j=0;j<n-i-1;++j$}
    	\IF{$data[i] > data[i+1]$}
    	\STATE data[i]とdata[i+1]を入れ替える
	\ENDIF
	\ENDFOR
	\ENDFOR
	\end{algorithmic}
\end{algorithm}
\end{figure}
このアルゴリズムはforループの繰り返しの数から計算量はおおよそ
\begin{eqnarray}
\sum_{i=0}^{n-1}(n-i)
\end{eqnarray}
となるので、$\mathcal{O}(n^{2})$となる。
\subsection{セレクションソート}
セレクションソートでは、数字の列から最大の数を探してきて$n$番目の数字と入れ替えます。
次に先頭から$n-1$番目の数字の中から最大の数を探して出して、$n-1$番目の数字と入れ替えます。
以下同様に繰り返すとソートを実現できます。

セレクションソートを実際に行った例を以下に示します。最初の数字の列は式(\ref{example init})で与えられるとします。
まず、最大の数字を探すと$8$であることがわかるので最後の数字である6と入れ替えます。
\begin{eqnarray}
5, 4, 6, 1, 3, 2, 7, 8
\end{eqnarray}
次に先頭から7番目までの数字の中から最大のものを選んできます。ここでは7で7番目にあるので特に入れ替えは行いません。
\begin{eqnarray}
5, 4, 6, 1, 3, 2, 7, 8
\end{eqnarray}
先頭から6番目までの数字の中から最大の数字を選ぶと6なので6番目の数字である2と入れ替えます。
\begin{eqnarray}
5, 4, 2, 1, 3, 6, 7, 8
\end{eqnarray}
以下同様にして行うと
\begin{eqnarray}
3, 4, 2, 1, 5, 6, 7, 8\\
3, 1, 2, 4, 5, 6, 7, 8\\
2, 1, 3, 4, 5, 6, 7, 8\\
1, 2, 3, 4, 5, 6, 7, 8\\
1, 2, 3, 4, 5, 6, 7, 8
\end{eqnarray}
となり、最終的にソートされた数字の列が得られます。

セレクションソートを疑似コードを使って書くと以下のようになります。
\begin{figure}[H]
\begin{algorithm}[H]
	\caption{selection sort}
	\label{selection sort}
	\begin{algorithmic}[1]  
    	\FOR{$i=0;i<n;++i$}
    	\STATE $0~n-i-1$までの中から最大のものを探して$n-i-1$番目の数字と入れ替える。
	\ENDFOR
	\end{algorithmic}
\end{algorithm}
\end{figure}
このアルゴリズムはforループの繰り返しの中で最大値を探すために$n-i-2$回の比較が必要です。
そのためアルゴリズムの計算量として$\mathcal{O}(n^{2})$となる。
\subsection{インサーションソート}
インサーションソートではソートされていない部分から要素と取り出してソートされた場所の適切な位置に挿入するアルゴリズムです。
挿入するときには、挿入する位置より右側のデータを全て一つずつずらす必要があります。

以下に具体的に見てみます。再び最初の数字の列は式(\ref{example init})で与えられるとします。
最初に一番先頭の数字$5$はすでに１つのソートされた列だとします。
このとき未ソートの領域(2番目からn番目)から数字を選んでソートされた領域の適切な位置に挿入します。
ここでは2番目の数字4を選んで挿入します。
\begin{eqnarray}
4, 5,| 8, 1, 3, 2, 7, 6
\end{eqnarray}
列の中の$|$より左がソート済み領域、右が未ソート領域となっています。
ここまでで、先頭から2番目までソートされた領域になります。次に3番目以降の未ソートの領域から数字をとってきます。ここで
3番目の数字8をとってきます。これをソート領域に挿入すると挿入位置は3番目なので特に並び替えは起こりません。
\begin{eqnarray}
4, 5, 8,| 1, 3, 2, 7, 6
\end{eqnarray}
次に未ソート領域内の4番目の数字をソート済み領域に挿入します。
\begin{eqnarray}
1, 4, 5, 8,| 3, 2, 7, 6
\end{eqnarray}
以下同様に繰り返すと
\begin{eqnarray}
1, 3, 4, 5, 8,| 2, 7, 6\\
1, 2, 3, 4, 5, 8,| 7, 6\\
1, 2, 3, 4, 5, 7, 8,| 6\\
1, 2, 3, 4, 5, 6, 7, 8|
\end{eqnarray}
となり最終的に全ての領域がソートされた列となります。

インサーションソートを疑似コードで書くと以下のとおりです。
\begin{figure}[H]
\begin{algorithm}[H]
	\caption{insertion sort}
	\label{insertion sort}
	\begin{algorithmic}[1]  
    	\FOR{$i=1;i<n;++i$}
	\STATE $x={\rm data}[i]$
	\STATE $j=i$
	\WHILE{$j-1>0$ and ${\rm data}[j-1]>x$}
    	\STATE ${\rm data}[j] = {\rm data}[j-1]$
	\STATE $j = j-1$
	\ENDWHILE
	\STATE ${\rm data}[j] = x$
	\ENDFOR
	\end{algorithmic}
\end{algorithm}
\end{figure}
インサーションソートの計算時間を考えるために最悪の場合として入力が数字が大きい順に並んでいるとします。
このときには、ソート済み領域に次の数字を挿入するたびに全ての列を一つずつずらしていく必要があるため、
計算量は$\mathcal{O}(n^{2})$となります。一方で、入力がほとんど小さい順番に並んでいるときには
列をずらす操作がほとんど不要となり、結局n回の数字の比較で済みます。ゆえにその場合には計算時間は$\mathcal{O}(n)$となります。
\subsection{シェルソート}
バブルソートやインサーションソートはデータを一つずつ移動していくため効率が悪くなります。そこで$h>1$を適当に決めて$h$ずつ飛び飛びで比較して
データの交換を行う方法が考えられます。これを$h$-整列といいます。

いま例えば、式(\ref{example init})に対して$h=2$とした$h$-整列を行ってみます。
このときには数字を一つ跳びごとに選んで小さな列を作ります。それぞれの列は以下のようになります。
\begin{eqnarray}
5, ~,  8, ~, 3, ~, 7, ~\\
~, 4,  ~, 1, ~, 2, ~, 6
\end{eqnarray}
このそれぞれの列をソートします。ここではインサーションソートをします。まず一つ目の列については
\begin{eqnarray}
5,| ~,  8, ~, 3, ~, 7, ~\\
5, ~,  8,| ~, 3, ~, 7, ~\\
3, ~,  5, ~,  8,| ~, 7, ~\\
3, ~,  5, ~,  7, ~, 8,| ~
\end{eqnarray}
を得ます。また二つ目の列については
\begin{eqnarray}
 4,|  ~, 1, ~, 2, ~, 6\\
 1,  ~, 4,| ~, 2, ~, 6\\
 1,  ~, 2, ~, 4,| ~, 6\\
 1,  ~, 2, ~, 4, ~, 6|\\
\end{eqnarray}
となります。この二つを合わせると
\begin{eqnarray}
3, 1, 5,  2, 7, 4, 8, 6 
\end{eqnarray}
を得ます。これが$h(=2)$-整列です。

シェルソートでは$h$の値を変えながら$h$-整列を行うソートアルゴリズムです。
効率を上げるには初めは$h$の値を大きく取り、数字を大きく移動させていくことが大切です。
以下では$h={\rm int}(n/2)$から始めて$h$を順番に半分して小さくするように$h$を選んで具体的に
シェルソートを確認してみます。
初期の列を式(\ref{example init})として$n=8$なので、最初は$h=4$です。$h=4$で$h$-整列を行うと
\begin{eqnarray}
3, 4, 8, 1, 5, 2, 7, 6\\
3, 2, 8, 1, 5, 4, 7, 6\\
3, 2, 7, 1, 5, 4, 8, 6
\end{eqnarray}
となります。次に$h=2$として
\begin{eqnarray}
3, 2, 7, 1, 5, 4, 8, 6\\
3, 1, 7, 2, 5, 4, 8, 6\\
3, 1, 5, 2, 7, 4, 8, 6
\end{eqnarray}
となります。最後に$h=1$として
\begin{eqnarray}
1, 3, 5, 2, 7, 4, 8, 6\\
1, 2, 3, 5, 7, 4, 8, 6\\
1, 2, 3, 4, 5, 7, 8, 6\\
1, 2, 3, 4, 5, 6, 7, 8
\end{eqnarray}
を得ます。
以上のシェルソートのアルゴリズムを疑似コードを示します。
\begin{figure}[H]
\begin{algorithm}[H]
	\caption{shell sort}
	\label{shell sort}
	\begin{algorithmic}[1]
	\STATE $g={\rm int}(n/2)$  
	\WHILE{$g>0$}
	\FOR{$i=g,g<n$}
	\STATE $t={\rm data}[i]$
	\STATE $j=i$
	\WHILE{$j\geq g ~\&~ {\rm data}[j-g] > t$}
	\STATE ${\rm data}[j] = {\rm data}[j-g]$
	\STATE $j = j-g$
	\ENDWHILE
	\STATE ${\rm data}[j] = t$
	\ENDFOR
	\STATE $g = {\rm int}(g/2)$
	\ENDWHILE
	\STATE ${\rm data}[j] = x$
	\end{algorithmic}
\end{algorithm}
\end{figure}
この疑似コードでは３行目から１１行目まででインサーションソートを$g$ごとに行っています。
シェルソートの計算量は$\mathcal{O}(n\log n)$程度であるようです。
\subsection{ヒープソート}
次にヒープソートについて説明します。ヒープソートはヒープと呼ばれるデータ構造を用いてソートを行う方法です。
ここではまずヒープについて説明します。
\subsubsection{ヒープとは}
ヒープは木構造と呼ばれるデータ構造の一種です。木構造は、いくつかの節点と節点を結ぶ枝から構成されています。
節点はデータを蓄える場所で枝はデータ間の関係を表しています。
木構造には根と呼ばれる節点が一つあり、根から枝が伸びる形て木構造が作られていく。二つの節点uとvが枝で繋がっていて
uがvよりも根に近いときuはvの親とよび、vはuの子と呼びます。根以外の節点は必ず親を１つ持ちます。
どの節点も高々k個の子しか持たない木構造をk分木と呼び、特にk=2を２分木と呼びます。
根から最短でk本の枝を通って節点に行けるとき、その節点はレベルkであるといいます。根はレベル０とします。
二分木の場合レベルkにある節点の数はおよそ$2^{k}$個となります。よって最大レベルがkの木構造には$2^{k+1}-1$個の
節点が存在します。

２分木は例えば以下のような構造になります。
 \begin{figure}[H]
 \begin{center}
\includegraphics[width=100mm]{tree_example.png}
\end{center}
\end{figure}
この例ではレベルは２までとなります。

ヒープでは２分木を考え、特にデータの最大値を探しやすいようなデータ構造とします。のちに詳しく説明しますが、
ヒープでは最大値を根の位置に割り当てます。データを追加する際には追加したいデータと根を比較して大きな方を根に残します。
小さかった方は保持して左か右の子に移動して、同様のことを繰り返します。このとき、根から見て左右の木構造ができるだけバランスよく
構成されていた方が便利です。そこでヒープではデータ数が$n$のときは$k$
\begin{eqnarray}
2^{k}-1< n \leq 2^{k+1}-1
\end{eqnarray}
を満たす自然数として、レベル$k-1$までの全ての節点にデータを格納したのち、残りのデータをレベル$k$に格納することで木構造のバランスを保つようにします。
さらにレベル$k$にデータを追加するときも最も左の節点からデータを追加していきます。

このルールの下でヒープのかく節点に１から番号をつけていきます。まず根には１の番号を振ります。次にレベル１に移動し左から順に２、３の番号を振ります。
レベル２ではレベル１の２の節点の子の左から４、５を割り振り次にレベル１の３の節点の子の左から６、７の番号を振ります。以下同様に番号を振っていきます。
 \begin{figure}[H]
 \begin{center}
\includegraphics[width=100mm]{heap_number.png}
\end{center}
\end{figure}
今、一番大きなレベルの節点には左からデータを蓄えているので、このような番号づけで一意に節点を区別できます。またこの番号付だとm番目の節点の子の番号は
$2m$と$2m+1$で与えられることがわかります。
 \begin{figure}[H]
 \begin{center}
\includegraphics[width=100mm]{heap_number2.png}
\end{center}
\end{figure}
この番号付をプログラムの配列のラベルと同一視することで、配列を用いて木構造を表現することができます。

次に節点にデータを蓄える時のルールについて説明します。
ヒープではどの枝に対しても、親には子よりも大きなデータを保存するようにします。このルールにより根は必ずデータの最大値となります。
 \begin{figure}[H]
 \begin{center}
\includegraphics[width=100mm]{heap_store.png}
\end{center}
\end{figure}
ここまでの議論からデータ数がnのヒープの最大レベルは$[{\rm log}_{2}(n+1)]-1$で与えられることがわかります。
以上のルールをまとめます。
\begin{enumerate}
\item 根には番号１を割り当てます。
\item 番号$m$の左は$2m$で、右は$2m+1$とします。
\item データ数$n$を超える番号を持つ節点は存在しません。
\item どの枝に対しても、親は子よりも大きな数字を蓄えます。
\end{enumerate}

\subsubsection{ヒープへのデータの格納}
今n個のデータを蓄えているヒープがあるとして、そこに$n+1$個目のデータを追加する方法を考えます。まず、ヒープの木構造から$n+1$個目のデータを
追加したいときに増えるべき節点の位置は一意に決まります。$n+1$が偶数なら新たに追加する節点は$\frac{n+1}{2}$の左側の子、$n+1$が奇数なら新たに追加する節点は$\frac{n}{2}$の右側の子となります。
親の番号はどちらの場合もまとめて$[\frac{n+1}{2}]$となります。

$n+1$番目のデータの追加は次のように行います。以下では${\rm data}$という配列でヒープを表すことにます。
まず、追加したいデータを一時的に$n+1$番目の節点におきます。この時、追加した数字が親の数字より大きいときにはヒープのルールを満たしません。
そこで他との大小関係を確認する必要があります。親のデータは${\rm data}[[\frac{n+1}{2}]]$で与えられます。もし追加したデータが親のデータより大きい場合、すなわち
\begin{eqnarray}
{\rm data}[n+1]>{\rm data}[[\frac{n+1}{2}]]
\end{eqnarray}
の時には親のデータと交換します。交換したら、交換した先でさらに親のデータと大小関係を比較し親のデータが小さければ交換します。この作業を繰り返し子が親より小さなデータを蓄えるように
なったらデータの追加が完了です。以下に42の数字を追加するときのヒープの変化を示します。
 \begin{figure}[H]
 \begin{center}
\includegraphics[width=100mm]{heap_append_example.png}
\end{center}
\end{figure}
赤色の線が子と親の代償関係が不整合になっている箇所です。そこの場所ではこのデータ(42)と親のデータ(26)を入れ替えます。入れ替えた先でさらに親のデータ(41)と追加データ(42)の大小関係が不整合
なのでデータを入れ替えます。最後には親と子の代償関係が整合するヒープが構成できました。

このヒープに対するデータの追加のアルゴリズムを疑似コード書くと以下のようになります。(配列のラベルは0から始めることに注意してください。)
\begin{figure}[H]
\begin{algorithm}[H]
	\caption{push heap}
	\label{push heap}
	\begin{algorithmic}[1]
	\STATE $x$ : 追加したいデータ 
	\STATE $n$: 追加する前のヒープが蓄えているデータ数
	\STATE $n ++$
	\STATE {\rm data}[n-1] = x
	\STATE $i=n$
	\STATE $j={\rm int}(i/2)$
	\WHILE{$j>0~\&~x > {\rm data}[j-1]$}
	\STATE {\rm data}[i-1]={\rm data}[j-1]
	\STATE $i=j$
	\STATE $j = {\rm int}(i/2)$
	\ENDWHILE
	\STATE ${\rm data}[i-1] = x$
	\end{algorithmic}
\end{algorithm}
\end{figure}
\subsubsection{最大データの取り出し}
次にヒープから最大の数を取り出す方法について説明します。
最大データは根にあります。問題は根のデータを削除した後に如何にしてヒープを再構成するのかです。
ヒープの根のデータを取り出すと、ヒープに蓄えられているデータの数が一つ減ります。ヒープを再構成するために、
まず一時的にヒープの末尾のデータを根に移動させます。これによってヒープの木構造は保たれます。しかし、末尾のデータは一般に小さな数字なので
それを根に移動すると親と子の大小関係が満たされなくなります。そこで親と子の大きさを比較してどちらかの子が親より大きかったら、データの移動が必要になります。
以下にヒープから最大値を取り出してヒープを再構成するアルゴリズムを示します。
\begin{figure}[H]
\begin{algorithm}[H]
	\caption{delete heap}
	\label{delete heap}
	\begin{algorithmic}[1]
	\STATE $n$: 削除する前のヒープが蓄えているデータ数
	\STATE $x={\rm data}[0]$
	\STATE $n--$
	\STATE ${\rm data}[0]={\rm data}[n-1]$
	\STATE $i=1$
	\WHILE{$2i \leq n$}
	\STATE $j=2i$
	\IF{$2i+1\leq n ~\&~{\rm data}[2i-1]<{\rm data}[2i]$}
	\STATE $j=2i+1$
	\ENDIF
	\IF{${\rm data}[i-1] \geq {\rm data}[j-1]$}
	\STATE break
	\ELSE
	\STATE $t={\rm data}[i-1]$
	\STATE ${\rm data}[i-1]={\rm data}[j-1]$
	\STATE ${\rm data}[j-1]=t$
	\ENDIF
	\STATE $i=j$
	\ENDWHILE
	\STATE return $x$
	\end{algorithmic}
\end{algorithm}
\end{figure}


\begin{thebibliography}{9}
\item 辻真吾、下平英寿、「Pythonで学ぶアルゴリズムとデータ構造」
\end{thebibliography}

\end{document}
